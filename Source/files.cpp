#include "stdafx.h"
#include <boost/regex.hpp>
#include <boost/lexical_cast.hpp>

#include "files.hpp"

static const boost::regex stackPat(".*_stack([0-9]+)_.*");

bool isTiffFile(const fs::path &p) {
	static const boost::regex tiffPat(".*.tiff?$");
	return boost::regex_match(p.string(), tiffPat);
}

bool isSpimGenTiff(const std::string &s, boost::smatch &m) {
	return boost::regex_match(s, m, stackPat);
}

bool isSpimGenTiff(const std::string &s) {
	return boost::regex_match(s, stackPat);
}

int extractStackId(const fs::path &p) {
	boost::smatch smat;
	int id = -1;
	std::string fname = p.filename().string();
	if (isSpimGenTiff(fname, smat)) {
		try {
			id = boost::lexical_cast<int>(smat[1]);
		} catch (boost::bad_lexical_cast &) {
		}
	}
	return id;
}

struct cmpStackId {
	inline bool operator()(const fs::path &p1, const fs::path &p2) {
		return extractStackId(p1) < extractStackId(p2);
	}
};

/*
 * List all the TIFF images in the folder.
 */
void listTiffFiles(const fs::path &root, std::vector<fs::path> &ret) {
	if (!fs::exists(root) || !fs::is_directory(root)) {
		return;
	}

	fs::directory_iterator it(root);
	fs::directory_iterator endit;
	while (it != endit) {
		if (fs::is_regular_file(*it) && isTiffFile(it->path())) {
			ret.push_back(it->path().string());
			++it;
		}
	}
}

/*
 * Sort SPIM generated stacks in numerical order.
 * Return number of files, not generated by SPIM, removed from the list.
 */
int sortSpimStacks(std::vector<fs::path> &lst) {
	std::sort(lst.begin(), lst.end(), cmpStackId());

	int rmCnt = 0;
	lst.erase(
		std::remove_if(
			lst.begin(),
			lst.end(),
			[&rmCnt](const fs::path &p) {
				std::string s = p.filename().string();
				if (isSpimGenTiff(s)) {
					return false;
				} else {
					rmCnt++;
					return true;
				}
			}
		), lst.end()
	);
	return rmCnt;
}
